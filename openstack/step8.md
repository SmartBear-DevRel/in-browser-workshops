## Client Code Generation & Contract Testing

A benefit of design-first based from an API description, is that it allows teams to work in parallel. Our provider codebase has not been developed, however we can make strides on the consumer side, leveraging our agreed API description at each step, to ensure that when we do integrate, our systems can talk correctly.

### Tools Used

1. Swagger CodeGen
2. Pact
3. Swagger-Mock-Validator

The Swagger Codegen project, allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec, and is available in a multitude of [different languages](https://github.com/swagger-api/swagger-codegen?tab=readme-ov-file#overview).

We are going to leverage it to create a client SDK, from our API description.

One of the great features in the ability to [customise](https://github.com/swagger-api/swagger-codegen?tab=readme-ov-file#modifying-the-client-library-format) the existing templates, or create your own.

We've consistently seen high-performing organisations leverage some kind of base-repo setup for teams creating new API's and this can allow for standard and consistent tooling across multiple projects, down to linters, unit testing tools and more.

In our case, we will introduce Pact, a contract-testing tool designed to work alongside your code-base at a unit testing level. It will allow us to utilise a powerful mock server during our consumers unit tests, ensuring that the requests our consumer makes to external collaborates are captured and correct as per the developers expectations. These contracts can then be shared with a provider, which once they have implemented their service, can verify that their service can fulfill the consumers requirements.

In the case of a client SDK, generated from an API description, the chance for drift is relatively low. Pact additionally provides a Pact Broker which allows the recording of these interactions between services, allow for a clear view at any one time, of the true nature of the interactions with a system, and which consumers may rely on any API, and granularity down to a field level, as to what consumers need.

The Pact project is embedded in a template called `typescript-fetch-pact`. It will generate a Pact test file, using the `pact-js` project, with a test covering each endpoint in the OpenAPI description.

When the unit test in ran, a set of Pact contracts are created, called pact files. These are a json document conforming to the Pact-specification, which defines the interactions, as tested, between a consumer and provider. The benefits of running at this layer, is quick feedback and high alignment with the consumer codebase, ensuring that as the consumer codebase changes, the contracts are regenerated.

We mentioned at the start of this step, that our provider is not yet available, however we can leverage another open-source tool, Swagger-Mock-Validator, developed by the Atlassian team, in order to ensure the Pact contracts generated by the consumer, are a valid subset of the OpenAPI specification. This would provide greater benefit where the consumer codebase was not generated by the OpenAPI file, however it can provide value in ensuring your contracts generated do not place undue burden on a provider to deliver functionality not described in the API description.

 You can read more about why it came to be, for Atlassian in their blog post [Using spec-first API development for speed and sanity](https://www.atlassian.com/blog/technology/spec-first-api-development). The PactFlow team forked the project, available on GitHub - [https://github.com/pactflow/swagger-mock-validator](https://github.com/pactflow/swagger-mock-validator), to higher align the project with some of the safety guarantees the Pact project offers. If you'd like some background as to why we think it's incompatible for more generic workflows, you can read this [issue](https://bitbucket.org/atlassian/swagger-mock-validator/issues/84/test-incorrectly-passes-when-mock-expects)

For our purposes we will be using the [@pactflow/swagger-mock-validator](https://www.npmjs.com/package/@pactflow/swagger-mock-validator) npm project.

If discrepancies are identified but a consumer deems these to be due to required functionality in the providing API, they can edit the API description, utilising previous tools used (Swagger Editor -> Spectral), providing a discussion point with the provider team.

### Steps

1. Fetch and build the Swagger CodeGen Project
   1. `make swagger_codegen_cli_fetch`{{exec}}
   2. `make swagger_codegen_generators_fetch`{{exec}}
   3. `make swagger_codegen_generators_build`{{exec}}
2. Generate the consumer template
   1. `make swagger_codegen_generators_generate`{{exec}}
   2. `make consumer_project_install`{{exec}}
3. Test the consumer project utilising Pact
   1. `make consumer_project_test`{{exec}}
4. Verify Pact's generated Consumer contracts against the OpenAPI
   1. `make consumer_project_verify_pact_openapi`{{exec}}

### Check

Before moving to the next step, check the following:

1. You have been able to build the `Swagger-codegen-generators` project
2. You have generated a consumer `typescript-fetch-pact` project from the consumer `typescript-fetch-pact` template
3. You have been able to install the consumer project dependencies with `npm install`
4. You have been able to run the consumer contract tests with `npm test`
5. You have been able to verify the generated Pact contract against the API description with `make consumer_project_verify_pact_openapi`
